```js
function getDecompositions(num) {
  const result = new Set();

  function backtrack(current, remaining) {
    if (remaining === 0) {
      result.add(current.join(''));
      return;
    }

    for (let i = 1; i <= remaining; i++) {
      current.push(i);
      backtrack(current, remaining - i);
      current.pop();
    }
  }

  function generatePermutations(arr) {
    const result = new Set();

    function permute(current, remaining) {
      if (remaining.length === 0) {
        result.add(current.join(''));
        return;
      }

      for (let i = 0; i < remaining.length; i++) {
        current.push(remaining[i]);
        permute(current, remaining.slice(0, i).concat(remaining.slice(i + 1)));
        current.pop();
      }
    }

    permute([], arr);
    return Array.from(result);
  }

  backtrack([], num);
  const decompositions = Array.from(result);
  const finalResult = new Set();

  for (const decomposition of decompositions) {
    const permutations = generatePermutations(decomposition.split(''));
    for (const permutation of permutations) {
      finalResult.add(permutation);
    }
  }

  return Array.from(finalResult);
}
```

```md
团队刚转为unity技术栈，unity和webGL深度不够，不能碰到一个问题解决一个，需要有一个解决问题的系统性思维和方法论。抓住核心关键点，快速触达问题本质，下面是分析的思路

1、要解决什么问题

提升用户的使用体验，使交付产品达到客户的可运营状态

2、如何定义客户的可运营状态

用户平均加载时间降至15秒以内，90%以上的用户运行无卡顿，运行5分钟无崩溃

现状是什么：优化前的平均加载时间是45s，5分钟崩溃率大于20%，多人同屏卡顿严重

3、核心优化路径和策略

用户平均加载时间降至15秒 --> 降低首个场景加载时间

90%以上的用户运行无卡顿 --> 提升运行帧率

运行5分钟无崩溃 --> 降低内存消耗

其中最关键的是降低首个场景加载时间，只有用户先进来了，后面的优化才有价值。

先不管高深的技术细节，但只要对问题的核心方向把握对，才可以以最低投入达到最大的优化效果

三：落地策略
无论是哪种技术栈或者产品形态，用户从终端上点击到最终加载首个3D场景成功，必然会经历网络请求和CPU计算, 进一步进行分解这2块核心影响因素

3.1、加载时间
影响加载时间的因素很多，有网络稳定性，资源大小，后台服务性能因素以及对应的各类排练组合，无论那种因素，都需要根据产品形态和技术栈特点进行进一步梳理和挖掘

3.1.1因素1- 网络消耗
元宇宙类产品非常的消耗美术或者3D素材资料，网络的开销是大头，要千方百计的在这块做专门的针对性优化



3.1.1.1 因子1 - 资源大小
分析逻辑：

资源分为代码和场景美术资源两大类，元宇宙产品因为有大量3D场景，尤其依赖相关美术资源资源和三方引擎工具（如unity），如3D场景的资源AssetBundle打包策略就对最后资源包大小的影响比较大；unity的版本，代码压缩的格式和方法都会对资源的大小有重要影响，需要逐个进行分析



优化点：

1、资源包瘦身

代码包 - unityWeb包

--- Disable Unity不用的功能模块，减少打包量

---- 代码裁剪，利用unity自带的代码剪裁工具，在保障功能正常情况下，剪裁不必要引擎依赖库和代码

---- 清理不用的插件，对一些没有用到的三方插件进行清理

通过以上几个优化点，减少代码包体积44%(约2M），按照用户平均2M/秒的下载速度，至少节约1秒的加载时间

美术资源包 - 场景和物件AssetBundle包

对3D场景和物件的面数以及纹理贴图大小进行规范和限制，在保障美术效果前提下，引入LOD模型，优化一些不合理的模型，降低场景和物件资源的面数，通过设置合理的纹理贴图Texture大小和压缩格式降低纹理贴图资源量，最终降低资源AssetBundle包的大小

优化后，模型总面数从30w降至18M，场景资源包从19M降至13M，减少约31%，按照用户平均2M/秒的下载速度，至少节约3秒的加载时间

 

2、公共资源 - 如纹理贴图等

压缩贴图格式，通过升级unity引擎（升级至2021 LTS）在移动平台支持纹理贴图的ASTC格式压缩，降低纹理贴图大小，从而降低场景AssetBundle资源包大小

 

3、WebGL构建压缩格式

调整构建压缩策略，采用gzip和br压缩格式，进一步减少WebGL产物包体积大小约21%

3.1.1.2 因子2 - 资源的依赖
分析逻辑：

类试于服务端的java进程启动，需要逐个解析并加载对应的依赖jar包，才能使应用启动成功。服务端工程可以在发布时通过逐个发布，或者错开发布实例，做到不停服启动。但是对于终端应用，用户只能等待，需要尽量减少非必要依赖，缩短启动时间，原则和策略如下

资源拆分

检查是否有冗余或者无效的资源存在，资源的依赖关系树是否合理

资源延迟加载

是否有和首场景加载的无关的资源存在，如果是强依赖资源，有无其他更优的资源替代方案

优化策略：

1、优化依赖

梳理和分析有无冗余或者公共依赖，可以把一些公共依赖的资源单独提取出公共包，减少冗余依赖，进一步减少webGL产物包的大小

将主场景中引用的字体删除，采用运行时动态按需加载字体AssetBundle资源包，减少打包产物data.unityweb的大小，减少约12M

清理unity default resources中无用的资源，减少约3M无用资源。

总共减少15M资源，按照用户平均2M/秒的下载速度，节约7秒左右加载时间

2、延后加载

检查有无非强依赖项，不需要在首场景里用到的代码和资源都可以延后加载

代码

-- 对首个场景里不需要的三方代码，如三方SDK，非必要的代码进行剥离，延后下载，减少首个场景的代码包的大小，如将语音相关的SDK代码进行延后下载

-- 对代码进行剪裁，首个场景只加载和首个场景相关的代码，其他场景和业务代码进行拆解后延后加载

美术资源

对首场景里不需要的3D动态物件，声音，小地图等资源，进行按需延后加载

3.1.1.3 因子3 - 下载并行
分析逻辑

网络下载策略对移动端产品的资源加载时间影响很大，优化的逻辑和原则一般是

尽可能并行 -> 尽可能用满网络

尽可能复用 -> 已下载的资源尽可能复用，避免重复下载

优化点

1、本地缓存

一些AssetBundle包资源可以提前下载至浏览器本地，二次启动或访问的时候可以直接下载使用

2、预加载

webGL启动流程中，有一网络空闲期，此时正处在CPU密集型计算，进行unity引擎解析和启动，按照不同的机型持续2-4秒。在此段时间内，将一些较小的资源包提前下载，充分利用闲置的网络资源。按平均2M每秒的网速，2-4秒平均可以下载4-8M的AB包资源



3.1.1.4 因子4 - 网络带宽
分析逻辑

网络带宽情况一般会被归于用户侧不可控因素而被忽视，实际上从用户发起网络请求下载，到最终建链以及返回最终的资源AssetBundle包，中途经历了好几层我们可以优化和掌控的阶段，如CDN以及回源等，存在大量的优化空间

优化策略

当前场景的CDN是直接回源至专有的静态资源服务器（nginx），但是3D场景和物件的AssetBundle资源包大小一般是7-8M（比传统前端的html和js要大很多），在一旦资源包重新发布升级多个用户同时并发回源的情况下，很快就会把静态资源服务器带宽打满，

改CDN回源至商用稳定的文件存储服务器如NOS，减少在新的资源发布后，因为用户集中访问造成的带宽资源不够而加载时间变长

3.1.1.5 因子5 - 接口信令响应时间
分析逻辑：

强弱依赖请求

是否有一些对首场景加载非强依赖的请求可以延后请求或交互的，延迟后请求后可以进一步加快用户进入首个场景

慢请求

从协议层还是数据层检查是否有一些接口慢请求可以进一步优化

优化策略：

1、服务器消息延后上报 --> 非首场景的必要的消息延后推送

2、配置请求瘦身 --> 首次进入只拉取和首场景相关的的配置，其他配置延后加载

3、协议优化 --> 部分走http的配置请求复用已有websocket链接推送

3.1.2 因素2 - CPU计算时间
不同于服务端系统，终端上的CPU计算时间会极大影响应用的加载和启动时间，尤其是低端机型的，对CPU密集型计算任务和逻辑尤其敏感； 而且Unity WebGL底层基于WebAssembly，算力不及原生APP，约为Native原生APP的1/3，所以一些小小的改进就可以放大优化效果

分析逻辑：

稳定CPU的水位

第一性原理：尽可能的保障CPU计算均匀，减少各类阻塞和等待。

首个场景里一些计算量重，耗时长的场景对象加载和业务逻辑是否必须，是否可以延后加载，分摊加载压力；

一些强依赖计算的，只计算用户视野内最亟需的场景，动态物件和其他玩家或者NPC

优化策略：

1、分帧加载

首个场景目前按照距离和视野范围计算出，当前需要加载的动态物件，其他玩家，NPC，并采用分帧加载策略，避免在某一帧里做大量计算，提升用户进入首个场景的速度，并且在进入后无卡顿

2、流式加载

调整nginx配置，添加Content-Type: application/wasm 支持流式加载，可以边压缩边加载，将CPU计算均可能均匀分布，进一步减少加载时间

3.2、卡顿优化
最直接反映卡顿的量化指标就是帧率，通过使用通用的unity 性能分析工具Unity Profiler采样启动和运行前500帧的数据，拿到对应的关键指标进行分析优化

优化策略

优化场景美术资源，减少Drawcall，降低渲染压力

UI相关的AB包合并，优化UI界面加载逻辑，减少drawcall，优化模型面数和纹理贴图大小和压缩格式，进一步降低渲染压力

帧率限定

修改物理更新帧率，Fixed Timestep设置为 1 /35 = 0.0285ms，降低物理模考快更新频率；限定运行帧率为35 FPS，缓解设备发烫

引入对象池，降低对象频繁的创建和销毁

关注Update中的代码逻辑

替换不合理的Unity API使用，比如使用Unity提供的NoAlloc无内存开销的API，Transform缓存， 使用ID访问属性等等

使用AOI，更新和同步设定范围区域内的其他玩家，动态物件，展板，NPC等对象的数据 

3.3、崩溃率
H5或者小程序对应webGL的崩溃基本可以归类为移动设备内存限制，内存泄露以及设备的兼容性，对我们当前产品来说，最有收益行动是尽可能优化内存大小，减少内存占用

分析逻辑：

当前产品技术栈为unity引擎，需要高度关注有无引擎侧的版本优化和能力更新，这个是最快和成本最低的途径

通过untity profiler检查最占用内存的场景和对象，重点做专项优化

优化策略

1、升级2019的unity版本至2021 LTS，全面使用webgl2.0进行渲染，在手机端对纹理贴图使用ASTC压缩，降低贴图内存占用

2、动态加载图片比如展板数据，海报等图片支持ASCT格式 - 内存优化40-60m，节省运行内存50%+

3、模型对象池管理优化，大规模同屏场景切换的对象内存回收优化 - 解决了多人同屏下的高频崩溃问题

4、优化模型面数，降低Mesh内存占用

四：总结
通过上述的几个核心优化（8个版本），最终的优化结果

加载时间

多机型首次加载时间12秒 ， 提升67%，其中unity产物data包体优化至2.4MB，降低88%，drawcall降低至12，降低62%

5分钟崩溃率

崩溃率降低80%+，其中内存使用平均减少40-60MB，内存使用优化比例40%-60%。多场大型剧本杀任务超30分钟任务过程中，无用户崩溃或异常退出

多人同屏卡顿

安卓机型帧率平均提升20+，提升率280%以上，iphone机型帧率提升10+，提升率40%，元宇宙大型嘉年华和展会活动中，无用户反馈卡顿

 

回应文章的开头思考，无论是哪种技术栈，应用环境和产品形态，在解决疑难杂症或者系统性问题的时候，一定要深入创新性思考，探寻解决问题的本质，从第一性原理出发，掌握系统性解决问题的方法论, 即使不熟悉技术，产品和业务，也能快速推进和解决问题，达到预期效果

```